[
  {
    "QuestionID": "Question 1",
    "Question": "Can You Perform Binary Search On Un-Ordered Arrays?",
    "Options": [
      "Yes",
      "No"
    ],
      "Answer": "No"
  },
  {
      "QuestionID": "Question 2",
      "Question": "In Regards To Binary Search, Which Statement Is True?",
      "Options": [
        "Hi = End of Array, Lo = Start of Array, Mid = (Hi + Lo) / 2",
        "Hi = Start of Array, Lo = End of Array, Mid = (Hi + Lo) / 2",
        "Hi = End of Array, Lo = Start of Array, Mid = (Hi - Lo) / 2",
        "None"
      ],
      "Answer": "Hi = End of Array, Lo = Start of Array, Mid = (Hi + Lo) / 2"
  },
  {
      "QuestionID": "Question 3",
      "Question": "In This Array, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], What Is Hi, Lo, Mid (Index)?",
      "Options": [
        "0, 9, 5",
        "9, 0, 4",
        "0, 9, 4",
        "9, 0, 5"
      ],
      "Answer": "9, 0, 4"
  },
  {
      "QuestionID": "Question 4",
      "Question": "What is the time complexity of a binary search algorithm in the worst case?",
      "Options": [
        "O(1)",
        "O(log n)",
        "O(n)",
        "O(n log n)"
      ],
      "Answer": "O(log n)"
  },
  {
      "QuestionID": "Question 5",
      "Question": "In a binary search algorithm, what condition is used to terminate the search?",
      "Options": [
        "The target value is less than the smallest value in the array.",
        "The low pointer crosses the high pointer.",
        "The target value is greater than the largest value in the array.",
        "The array is completely sorted."
      ],
      "Answer": "The low pointer crosses the high pointer."
  },
  {
      "QuestionID": "Question 6",
      "Question": "What will be the middle index when performing a binary search on this array [10, 20, 30, 40, 50, 60, 70, 80, 90] in the first iteration?",
      "Options": [
        "4",
        "3",
        "5",
        "6"
      ],
      "Answer": "4"
  },
  {
  "QuestionID": "Question 5",
  "Question": "If the target value is greater than the value at the middle index during a binary search, what should be the next step?",
  "Options": [
      "Search in the left half of the array.",
      "Search in the right half of the array.",
      "Repeat the search on the entire array.",
      "Stop the search."
    ],
    "Answer": "Search in the right half of the array."
  },
  {
      "QuestionID": "Question 7",
      "Question": "Consider the array [2, 5, 8, 12, 16, 23, 38, 56, 72, 91]. If you are searching for the number 23 using binary search, how many iterations will it take to find it?",
      "Options": [
          "1",
          "2",
          "3",
          "4"
      ],
      "Answer": "4"
  },
  {
      "QuestionID": "Question 8",
      "Question": "In Java, which of the following is a correct way to calculate the middle index in a binary search?",
      "Options": [
          "mid = (low + high) / 2;",
          "mid = low + (high - low) / 2;",
          "mid = (low * high) / 2;",
          "mid = (high - low) / 2 + low;"
      ],
      "Answer": "mid = (low + high) / 2;"
  },
  {
      "QuestionID": "Question 9",
      "Question": "When implementing a binary search in Java, what type of loop is commonly used?",
      "Options": [
          "A for-loop",
          "A while-loop",
          "A do-while loop",
          "An if statement"
      ],
      "Answer": "An if statement"
  },
  {
      "QuestionID": "Question 10",
      "Question": "What is the space complexity of the iterative version of binary search?",
      "Options": [
          "O(1)",
          "O(log n)",
          "O(n)",
          "O(n log n)"
      ],
      "Answer": "O(1)"
  },
  {
      "QuestionID": "Question 11",
      "Question": "If a binary search is performed on an array with the elements [3, 7, 10, 15, 18, 22, 27], what will be the middle element in the second iteration when searching for the number 10?",
      "Options": [
          "3",
          "7",
          "15",
          "18"
      ],
      "Answer": "7"
  },
  {
  "QuestionID": "Question 12",
  "Question": "What is the time complexity of the Insertion Sort algorithm in the best case scenario?",
  "Options": [
      "O(1)",
      "O(n)",
      "O(n^2)",
      "O(log n)"
    ],
    "Answer": "O(n)"
  },
  {
      "QuestionID": "Question 13",
      "Question": "Which of the following scenarios best suits the use of Insertion Sort?",
      "Options": [
          "Large datasets",
          "Data sets that are almost sorted",
          "Data sets with complex data structures",
          "When memory space is extremely limited"
      ],
      "Answer": "Data sets that are almost sorted"
  },
  {
      "QuestionID": "Question 14",
      "Question": "In Insertion Sort, each iteration sorts a list of how many elements?",
      "Options": [
          "One element",
          "Two elements",
          "The entire list",
          "Half of the list"
      ],
      "Answer": "One element"
  },
  {
      "QuestionID": "Question 15",
      "Question": "What is the space complexity of Insertion Sort?",
      "Options": [
          "O(1)",
          "O(n)",
          "O(n^2)",
          "O(log n)"
      ],
      "Answer": "O(1)"
  },
  {
      "QuestionID": "Question 16",
      "Question": "Which of the following statements is true about Insertion Sort?",
      "Options": [
          "It is not a stable sort.",
          "It uses divide and conquer.",
          "It is more efficient than Quick Sort for small data sets.",
          "It cannot be used on partially sorted arrays."
      ],
      "Answer": "It is more efficient than Quick Sort for small data sets."
  },
  {
  "QuestionID": "Question 17",
  "Question": "Consider the array [5, 3, 8, 4, 2]. After the first pass of Insertion Sort, what will the array look like?",
  "Options": [
      "[5, 3, 8, 4, 2]",
      "[3, 5, 8, 4, 2]",
      "[5, 8, 3, 4, 2]",
      "[2, 3, 4, 5, 8]"
      ],
      "Answer": "[3, 5, 8, 4, 2]"
  },
  {
      "QuestionID": "Question 18",
      "Question": "In which pass of Insertion Sort would the number '1' be correctly positioned in the array [4, 3, 1, 5, 2]?",
      "Options": [
          "First pass",
          "Second pass",
          "Third pass",
          "Fourth pass"
      ],
      "Answer": "Third pass"
  },
  {
      "QuestionID": "Question 19",
      "Question": "For the array [6, 1, 5, 2, 4], how many swaps are required in the second pass of Insertion Sort?",
      "Options": [
          "0",
          "1",
          "2",
          "More than 2"
      ],
      "Answer": "1"
  },
  {
      "QuestionID": "Question 20",
      "Question": "What is the position of '7' after the first pass of Insertion Sort on the array [7, 5, 3, 9, 8]?",
      "Options": [
          "Position 1",
          "Position 2",
          "Position 3",
          "Position 4"
      ],
      "Answer": "Position 2"
  },
  {
      "QuestionID": "Question 21",
      "Question": "How many comparisons are made in the third pass of Insertion Sort when sorting the array [8, 4, 5, 3, 1]?",
      "Options": [
          "1",
          "2",
          "3",
          "4"
      ],
      "Answer": "3"
  },
  {
  "QuestionID": "Question 22",
  "Question": "How does Insertion Sort behave with duplicate elements in the array?",
  "Options": [
      "It cannot handle duplicate elements.",
      "It places all duplicates at the end.",
      "It maintains the relative order of duplicate elements.",
      "It places all duplicates at the beginning."
      ],
      "Answer": "It maintains the relative order of duplicate elements."
  },
  {
      "QuestionID": "Question 23",
      "Question": "Which of the following best describes the adaptive nature of Insertion Sort?",
      "Options": [
          "Its performance adapts based on the initial order of elements.",
          "It changes its algorithm based on the data type.",
          "It adapts the memory usage based on the size of the data.",
          "It can sort both numeric and alphabetical data."
      ],
      "Answer": "Its performance adapts based on the initial order of elements."
  },
  {
      "QuestionID": "Question 24",
      "Question": "What is a disadvantage of Insertion Sort?",
      "Options": [
          "It is too complex to understand.",
          "It is not stable.",
          "It is inefficient for large lists.",
          "It cannot sort partially sorted arrays efficiently."
      ],
      "Answer": "It is inefficient for large lists."
  },
  {
      "QuestionID": "Question 25",
      "Question": "In Insertion Sort, which element starts as the sorted portion of the array?",
      "Options": [
          "The first element",
          "The last element",
          "The middle element",
          "None, the array starts unsorted"
      ],
      "Answer": "The first element"
  },
  {
      "QuestionID": "Question 26",
      "Question": "What characteristic of data makes Insertion Sort particularly efficient?",
      "Options": [
          "Data with many duplicates",
          "Data in completely random order",
          "Almost sorted data",
          "Data with large values"
      ],
      "Answer": "Almost sorted data"
  },
  {
      "QuestionID": "Question 27",
      "Question": "After the second pass of Insertion Sort on the array [9, 7, 5, 3, 1], what will the array look like?",
      "Options": [
          "[9, 7, 5, 3, 1]",
          "[7, 9, 5, 3, 1]",
          "[5, 7, 9, 3, 1]",
          "[7, 5, 9, 3, 1]"
      ],
      "Answer": "[5, 7, 9, 3, 1]"
  },
  {
      "QuestionID": "Question 28",
      "Question": "What is the final position of the number '6' in the sorted array using Insertion Sort for the array [4, 6, 2, 7, 3]?",
      "Options": [
          "Position 1",
          "Position 2",
          "Position 3",
          "Position 4"
      ],
      "Answer": "Position 3"
  },
  {
      "QuestionID": "Question 29",
      "Question": "How many total movements (swaps) are required to sort the array [3, 1, 2, 5, 4] using Insertion Sort?",
      "Options": [
          "3",
          "4",
          "5",
          "6"
      ],
      "Answer": "3"
  },
  {
      "QuestionID": "Question 30",
      "Question": "In which pass of Insertion Sort will the smallest element of the array reach its correct position in the array [8, 5, 1, 4, 6]?",
      "Options": [
          "First pass",
          "Second pass",
          "Third pass",
          "Fourth pass"
      ],
      "Answer": "Second pass"
  },
  {
      "QuestionID": "Question 31",
      "Question": "What is the number of comparisons needed in the fourth pass of Insertion Sort for the array [7, 4, 5, 2, 3]?",
      "Options": [
          "1",
          "2",
          "3",
          "4"
      ],
      "Answer": "4"
  },
  {
  "QuestionID": "Question 32",
  "Question": "What is the time complexity of Linear Search in the worst case scenario?",
  "Options": [
      "O(1)",
      "O(log n)",
      "O(n)",
      "O(n^2)"
      ],
      "Answer": "O(n)"
  },
  {
      "QuestionID": "Question 33",
      "Question": "What is the primary advantage of Linear Search over other search algorithms?",
      "Options": [
          "It is faster than binary search.",
          "It does not require the data to be sorted.",
          "It uses less memory.",
          "It can find the smallest element."
      ],
      "Answer": "It does not require the data to be sorted."
  },
  {
      "QuestionID": "Question 34",
      "Question": "Which of the following is true about Linear Search?",
      "Options": [
          "It is more efficient on large datasets than on small datasets.",
          "It requires additional space for its operation.",
          "It is considered a divide-and-conquer algorithm.",
          "It examines every element in the list until it finds the target."
      ],
      "Answer": "It examines every element in the list until it finds the target."
  },

  {
  "QuestionID": "Question 35",
  "Question": "For the array [5, 3, 8, 4, 2], what is the number of comparisons needed to find the value 4 using Linear Search?",
  "Options": [
      "2",
      "3",
      "4",
      "5"
      ],
      "Answer": "4"
  },
  {
      "QuestionID": "Question 36",
      "Question": "In which position will the number 7 be found during Linear Search in the array [9, 5, 7, 3, 1]?",
      "Options": [
          "Position 1",
          "Position 2",
          "Position 3",
          "Not found"
      ],
      "Answer": "Position 2"
  },
  {
      "QuestionID": "Question 37",
      "Question": "What will be the result of a Linear Search for the number 6 in the array [4, 2, 5, 1, 3]?",
      "Options": [
          "Found at Position 1",
          "Found at Position 4",
          "Not found",
          "Requires sorting first"
      ],
      "Answer": "Not found"
  },
  {
  "QuestionID": "Question 38",
  "Question": "What is the time complexity of Bubble Sort in the worst case scenario?",
  "Options": [
      "O(n^2)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ],
    "Answer": "O(n^2)"
  },
  {
      "QuestionID": "Question 39",
      "Question": "Which of the following best describes Bubble Sort?",
      "Options": [
          "It selects the smallest element and places it at the beginning.",
          "It divides the list into sorted and unsorted parts.",
          "It repeatedly swaps adjacent elements if they are in the wrong order.",
          "It creates a tree structure to sort elements."
      ],
      "Answer": "It repeatedly swaps adjacent elements if they are in the wrong order."
  },
  {
      "QuestionID": "Question 40",
      "Question": "What is the primary advantage of Bubble Sort?",
      "Options": [
          "It is the fastest sorting algorithm.",
          "It is useful for extremely large datasets.",
          "It is simple to understand and implement.",
          "It does not require extra memory for sorting."
      ],
      "Answer": "It is simple to understand and implement."
  },
  {
  "QuestionID": "Question 41",
  "Question": "After the first pass of Bubble Sort on the array [5, 3, 8, 4, 2], what will the array look like?",
  "Options": [
      "[3, 5, 4, 2, 8]",
      "[5, 3, 4, 2, 8]",
      "[3, 5, 8, 4, 2]",
      "[2, 3, 4, 5, 8]"
      ],
      "Answer": "[5, 3, 4, 2, 8]"
  },
  {
    "QuestionID": "Question 42",
    "Question": "How many total swaps are required to sort the array [3, 2, 1, 5, 4] using Bubble Sort?",
    "Options": [
        "6",
        "10",
        "4",
        "7"
    ],
    "Answer": "4"
  },
  {
    "QuestionID": "Question 43",
    "Question": "In which pass of Bubble Sort will the largest element of the array [4, 6, 1, 5, 3] reach its correct position?",
    "Options": [
        "First pass",
        "Second pass",
        "Third pass",
        "Fourth pass"
    ],
    "Answer": "First pass"
  },
  {
    "QuestionID": "Question 44",
    "Question": "What is a key feature of a recursive function?",
    "Options": [
        "It always contains a loop.",
        "It calls itself within its body.",
        "It cannot have any parameters.",
        "It is faster than iterative solutions."
    ],
    "Answer": "It calls itself within its body."
  },
  {
      "QuestionID": "Question 45",
      "Question": "What is essential for a recursive function to avoid infinite recursion?",
      "Options": [
          "A global variable",
          "A return statement",
          "A base case",
          "Multiple parameters"
      ],
      "Answer": "A base case"
  },
  {
      "QuestionID": "Question 46",
      "Question": "In the context of recursion, what is stack overflow?",
      "Options": [
          "When the program runs out of memory due to too many recursive calls",
          "A common error when the function returns the wrong value",
          "An issue when the function does not have a return statement",
          "A problem related to incorrect base case"
      ],
      "Answer": "When the program runs out of memory due to too many recursive calls"
  },
  {
      "QuestionID": "Question 47",
      "Question": "What does the term 'tail recursion' refer to?",
      "Options": [
          "A recursive call not in the tail position",
          "A recursion where the function calls itself multiple times in one statement",
          "A recursion where the last operation of a function is a recursive call",
          "A recursion that does not have a base case"
      ],
      "Answer": "A recursion where the last operation of a function is a recursive call"
  },
  {
      "QuestionID": "Question 48",
      "Question": "Which of the following is a disadvantage of recursion compared to iteration?",
      "Options": [
          "More memory usage due to stack frames",
          "Recursion cannot be used for complex algorithms",
          "Recursion is always slower than iteration",
          "Recursion cannot have multiple base cases"
      ],
      "Answer": "More memory usage due to stack frames"
  },
  {
      "QuestionID": "Question 49",
      "Question": "Which of these scenarios is most suitable for a recursive approach?",
      "Options": [
          "Calculating the sum of all elements in an array",
          "Implementing a binary search on a sorted array",
          "Sorting a small list of items",
          "Solving problems with a tree-like structure"
      ],
      "Answer": "Solving problems with a tree-like structure"
  },
  {
    "QuestionID": "Question 50",
    "Question": "What is the output of the following Java function when called with the argument 5?\n`int func(int n) { if (n == 1) return 1; else return n + func(n - 1); }`",
    "Options": [
        "5",
        "15",
        "10",
        "None of the above"
    ],
    "Answer": "15"
  },
  {
    "QuestionID": "Question 51",
    "Question": "How many recursive calls are made when the following Java function is called with func(3)\n`void func(int n) { if (n > 0) { System.out.println(n); func(n - 1); } }`",
    "Options": [
        "2",
        "3",
        "4",
        "1"
    ],
    "Answer": "3"
  },
  {
    "QuestionID": "Question 52",
    "Question": "Consider the recursive Java function:\n`int fibonacci(int n)<br>{ if (n <= 1) return n; else return fibonacci(n - 1) + fibonacci(n - 2); }`\nWhat is the result of `fibonacci(5)`?",
    "Options": [
        "3",
        "5",
        "8",
        "13"
    ],
    "Answer": "5"
  },
  {
    "QuestionID": "Question 53",
    "Question": "What is the number of recursive calls in the execution of `factorial(4)` with the following Java method?\n`int factorial(int n) { if (n == 1) return 1; else return n * factorial(n - 1); }`",
    "Options": [
        "3",
        "4",
        "5",
        "2"
    ],
    "Answer": "4"
  },
  {
      "QuestionID": "Question 54",
      "Question": "What is the base case in the following Java recursive method for calculating the power of a number?\n`int power(int base, int exp) { if (exp == 0) return 1; else return base * power(base, exp - 1); }`",
      "Options": [
          "`base == 0`",
          "`exp == 0`",
          "`base == 1`",
          "`exp == 1`"
      ],
      "Answer": "exp == 0"
  },
  {
      "QuestionID": "Question 55",
      "Question": "What will be the total sum returned by the following recursive Java function when called with `sum(3)`?\n`int sum(int n) { if (n <= 0) return 0; else return n + sum(n - 2); }`",
      "Options": [
          "2",
          "3",
          "4",
          "6"
      ],
      "Answer": "4"
  },
  {
    "QuestionID": "Question 56",
    "Question": "In Java, what is the primary difference between an ArrayList and a LinkedList when it comes to adding an element to the end of the list?",
    "Options": [
        "LinkedList is faster because it uses a dynamic array.",
        "ArrayList is faster because it uses a dynamic array.",
        "LinkedList is faster because it doesn't require an array resize.",
        "ArrayList and LinkedList have the same performance for this operation."
    ],
    "Answer": "LinkedList is faster because it doesn't require an array resize."
    },
    {
        "QuestionID": "Question 57",
        "Question": "What does the 'Node' class in a LinkedList typically contain?",
        "Options": [
            "Only the data for each element in the list.",
            "Data for each element and a reference to the next and previous nodes.",
            "A reference to the next node only.",
            "A reference to the previous node only."
        ],
        "Answer": "Data for each element and a reference to the next and previous nodes."
    },
    {
        "QuestionID": "Question 58",
        "Question": "Which method is used to add an element at the beginning of a LinkedList in Java?",
        "Options": [
            "addFirst()",
            "push()",
            "insertFirst()",
            "unshift()"
        ],
        "Answer": "addFirst()"
    },
    {
        "QuestionID": "Question 59",
        "Question": "What is the time complexity of removing an element from the middle of a LinkedList?",
        "Options": [
            "O(1)",
            "O(log n)",
            "O(n)",
            "O(n^2)"
        ],
        "Answer": "O(n)"
    },
    {
        "QuestionID": "Question 60",
        "Question": "When iterating through a LinkedList, why is it generally more efficient to use a for-each loop rather than a traditional for loop with an index?",
        "Options": [
            "A for-each loop uses less memory.",
            "LinkedList elements cannot be accessed using an index efficiently.",
            "A for-each loop is always faster than a for loop.",
            "LinkedList is not compatible with traditional for loops."
        ],
        "Answer": "LinkedList elements cannot be accessed using an index efficiently."
    },
    {
        "QuestionID": "Question 61",
        "Question": "In a singly linked list, how do you find the previous node of a given node?",
        "Options": [
            "By using the 'previous' reference in the given node.",
            "By iterating from the head of the list until you reach the node just before the given node.",
            "By accessing the previous element's index.",
            "By using the 'getPreviousNode()' method."
        ],
        "Answer": "By iterating from the head of the list until you reach the node just before the given node."
    },
    {
        "QuestionID": "Question 62",
        "Question": "What must be updated when adding a new node to the end of a singly linked list?",
        "Options": [
            "The 'next' reference of the head node.",
            "The 'next' reference of the last node.",
            "The 'previous' reference of the last node.",
            "The 'previous' reference of the head node."
        ],
        "Answer": "The 'next' reference of the last node."
    },
    {
    "QuestionID": "Question 63",
    "Question": "What will be the result of the following code snippet?\n`LinkedList<String> list = new LinkedList<>();\nlist.add(\"Apple\");\nlist.add(0, \"Orange\");\nSystem.out.println(list);`",
    "Options": [
        "[\"Apple\", \"Orange\"]",
        "[\"Orange\", \"Apple\"]",
        "[\"Apple\"]",
        "An error occurs."
    ],
    "Answer": "[\"Orange\", \"Apple\"]"
    },
    {
        "QuestionID": "Question 64",
        "Question": "If you have a LinkedList with elements [\"Node1\", \"Node2\", \"Node3\"], what is the value of 'head.next.data'?",
        "Options": [
            "\"Node1\"",
            "\"Node2\"",
            "\"Node3\"",
            "None of the above"
        ],
        "Answer": "\"Node2\""
    },
    {
        "QuestionID": "Question 65",
    "Question": "Considering a LinkedList with the initial elements [\"Node1\", \"Node2\"], what would be the result after executing the following Java code snippet?\n`list.addLast(\"Node3\"); list.removeFirst();`\n",
        "Options": [
            "[\"Node1\", \"Node2\"]",
            "[\"Node2\", \"Node3\"]",
            "[\"Node1\", \"Node3\"]",
            "[\"Node3\", \"Node1\"]"
        ],
        "Answer": "[\"Node2\", \"Node3\"]"
    },
    {
        "QuestionID": "Question 66",
        "Question": "What will be the size of a LinkedList after the following Java statements?\n`LinkedList<Integer> numbers = new LinkedList<>();\nnumbers.add(1);\nnumbers.add(2);\nnumbers.remove(1);\n`",
        "Options": [
            "0",
            "1",
            "2",
            "3"
        ],
        "Answer": "1"
    },
    {
        "QuestionID": "Question 67",
        "Question": "In Java, which method is commonly used to reverse a LinkedList?",
        "Options": [
            "reverse()",
            "invertList()",
            "Collections.reverse()",
            "LinkedList does not support reversing through a method."
        ],
        "Answer": "Collections.reverse()"
    },
    {
        "QuestionID": "Question 68",
        "Question": "What exception is thrown if you try to access an element in a LinkedList using 'get()' with an invalid index?",
        "Options": [
            "NullPointerException",
            "IllegalArgumentException",
            "IndexOutOfBoundsException",
            "NoSuchElementException"
        ],
        "Answer": "IndexOutOfBoundsException"
    },
    {
        "QuestionID": "Question 69",
        "Question": "What will the 'next' reference of the last node in a singly linked list point to?",
        "Options": [
            "The first node, making it circular",
            "null, indicating the end of the list",
            "A random node in the list",
            "It will not have a 'next' reference"
        ],
        "Answer": "null, indicating the end of the list"
    },
    {
        "QuestionID": "Question 70",
        "Question": "Given a 'Node' class with an 'int data' and 'Node next', which of the following Java code snippets correctly creates a two-node LinkedList with values 5 and 10?",
        "Options": [
            "`Node head = new Node(5); head.next = new Node(10);`",
            "`Node head = new Node(5); new Node(10);`",
            "`Node head = new Node(5); head.next = 10;`",
            "`Node head = new Node(5); head.next.data = 10;`"
        ],
        "Answer": "Node head = new Node(5); head.next = new Node(10);"
    },
    {
        "QuestionID": "Question 71",
        "Question": "How do you delete the entire LinkedList in Java?",
        "Options": [
            "By setting the head to null",
            "By using the clear() method",
            "By manually setting each node's next to null",
            "By iterating through the list and removing each element"
        ],
        "Answer": "By setting the head to null"
    }
]